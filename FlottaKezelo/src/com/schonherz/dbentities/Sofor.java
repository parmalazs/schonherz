package com.schonherz.dbentities;

import java.util.List;
import com.schonherz.dbentities.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table Soforok.
 */
public class Sofor {

    private Long soforID;
    private String soforNev;
    private String soforCim;
    private String soforTelefonszam;
    private String soforLogin;
    private String soforPass;
    private String soforBirthDate;
    private String soforRegTime;
    private Boolean soforIsAdmin;
    private String soforEmail;
    private Long soforProfilKepID;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient SoforDao myDao;

    private ProfilKep profilKep;
    private Long profilKep__resolvedKey;

    private List<ProfilKep> profilKepList;
    private List<Munka> munkaList;

    public Sofor() {
    }

    public Sofor(Long soforID) {
        this.soforID = soforID;
    }

    public Sofor(Long soforID, String soforNev, String soforCim, String soforTelefonszam, String soforLogin, String soforPass, String soforBirthDate, String soforRegTime, Boolean soforIsAdmin, String soforEmail, Long soforProfilKepID) {
        this.soforID = soforID;
        this.soforNev = soforNev;
        this.soforCim = soforCim;
        this.soforTelefonszam = soforTelefonszam;
        this.soforLogin = soforLogin;
        this.soforPass = soforPass;
        this.soforBirthDate = soforBirthDate;
        this.soforRegTime = soforRegTime;
        this.soforIsAdmin = soforIsAdmin;
        this.soforEmail = soforEmail;
        this.soforProfilKepID = soforProfilKepID;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getSoforDao() : null;
    }

    public Long getSoforID() {
        return soforID;
    }

    public void setSoforID(Long soforID) {
        this.soforID = soforID;
    }

    public String getSoforNev() {
        return soforNev;
    }

    public void setSoforNev(String soforNev) {
        this.soforNev = soforNev;
    }

    public String getSoforCim() {
        return soforCim;
    }

    public void setSoforCim(String soforCim) {
        this.soforCim = soforCim;
    }

    public String getSoforTelefonszam() {
        return soforTelefonszam;
    }

    public void setSoforTelefonszam(String soforTelefonszam) {
        this.soforTelefonszam = soforTelefonszam;
    }

    public String getSoforLogin() {
        return soforLogin;
    }

    public void setSoforLogin(String soforLogin) {
        this.soforLogin = soforLogin;
    }

    public String getSoforPass() {
        return soforPass;
    }

    public void setSoforPass(String soforPass) {
        this.soforPass = soforPass;
    }

    public String getSoforBirthDate() {
        return soforBirthDate;
    }

    public void setSoforBirthDate(String soforBirthDate) {
        this.soforBirthDate = soforBirthDate;
    }

    public String getSoforRegTime() {
        return soforRegTime;
    }

    public void setSoforRegTime(String soforRegTime) {
        this.soforRegTime = soforRegTime;
    }

    public Boolean getSoforIsAdmin() {
        return soforIsAdmin;
    }

    public void setSoforIsAdmin(Boolean soforIsAdmin) {
        this.soforIsAdmin = soforIsAdmin;
    }

    public String getSoforEmail() {
        return soforEmail;
    }

    public void setSoforEmail(String soforEmail) {
        this.soforEmail = soforEmail;
    }

    public Long getSoforProfilKepID() {
        return soforProfilKepID;
    }

    public void setSoforProfilKepID(Long soforProfilKepID) {
        this.soforProfilKepID = soforProfilKepID;
    }

    /** To-one relationship, resolved on first access. */
    public ProfilKep getProfilKep() {
        if (profilKep__resolvedKey == null || !profilKep__resolvedKey.equals(soforProfilKepID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ProfilKepDao targetDao = daoSession.getProfilKepDao();
            profilKep = targetDao.load(soforProfilKepID);
            profilKep__resolvedKey = soforProfilKepID;
        }
        return profilKep;
    }

    public void setProfilKep(ProfilKep profilKep) {
        this.profilKep = profilKep;
        soforProfilKepID = profilKep == null ? null : profilKep.getProfilKepID();
        profilKep__resolvedKey = soforProfilKepID;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<ProfilKep> getProfilKepList() {
        if (profilKepList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            ProfilKepDao targetDao = daoSession.getProfilKepDao();
            profilKepList = targetDao._querySofor_ProfilKepList(soforID);
        }
        return profilKepList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetProfilKepList() {
        profilKepList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<Munka> getMunkaList() {
        if (munkaList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MunkaDao targetDao = daoSession.getMunkaDao();
            munkaList = targetDao._querySofor_MunkaList(soforID);
        }
        return munkaList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetMunkaList() {
        munkaList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
