package com.schonherz.dbentities;

import com.schonherz.dbentities.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table Autokepek.
 */
public class AutoKep {

    private Long autoKepID;
    private String autoKepPath;
    private String autoKepDateTime;
    private Boolean autoKepIsUploaded;
    private Boolean autoKepIsActive;
    private Long autoID;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient AutoKepDao myDao;

    private Auto auto;
    private Long auto__resolvedKey;


    public AutoKep() {
    }

    public AutoKep(Long autoKepID) {
        this.autoKepID = autoKepID;
    }

    public AutoKep(Long autoKepID, String autoKepPath, String autoKepDateTime, Boolean autoKepIsUploaded, Boolean autoKepIsActive, Long autoID) {
        this.autoKepID = autoKepID;
        this.autoKepPath = autoKepPath;
        this.autoKepDateTime = autoKepDateTime;
        this.autoKepIsUploaded = autoKepIsUploaded;
        this.autoKepIsActive = autoKepIsActive;
        this.autoID = autoID;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getAutoKepDao() : null;
    }

    public Long getAutoKepID() {
        return autoKepID;
    }

    public void setAutoKepID(Long autoKepID) {
        this.autoKepID = autoKepID;
    }

    public String getAutoKepPath() {
        return autoKepPath;
    }

    public void setAutoKepPath(String autoKepPath) {
        this.autoKepPath = autoKepPath;
    }

    public String getAutoKepDateTime() {
        return autoKepDateTime;
    }

    public void setAutoKepDateTime(String autoKepDateTime) {
        this.autoKepDateTime = autoKepDateTime;
    }

    public Boolean getAutoKepIsUploaded() {
        return autoKepIsUploaded;
    }

    public void setAutoKepIsUploaded(Boolean autoKepIsUploaded) {
        this.autoKepIsUploaded = autoKepIsUploaded;
    }

    public Boolean getAutoKepIsActive() {
        return autoKepIsActive;
    }

    public void setAutoKepIsActive(Boolean autoKepIsActive) {
        this.autoKepIsActive = autoKepIsActive;
    }

    public Long getAutoID() {
        return autoID;
    }

    public void setAutoID(Long autoID) {
        this.autoID = autoID;
    }

    /** To-one relationship, resolved on first access. */
    public Auto getAuto() {
        if (auto__resolvedKey == null || !auto__resolvedKey.equals(autoID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            AutoDao targetDao = daoSession.getAutoDao();
            auto = targetDao.load(autoID);
            auto__resolvedKey = autoID;
        }
        return auto;
    }

    public void setAuto(Auto auto) {
        this.auto = auto;
        autoID = auto == null ? null : auto.getAutoID();
        auto__resolvedKey = autoID;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
