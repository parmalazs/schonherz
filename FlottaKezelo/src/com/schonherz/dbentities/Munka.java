package com.schonherz.dbentities;

import java.util.List;
import com.schonherz.dbentities.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table Munkak.
 */
public class Munka {

    private Long munkaID;
    private Long munkaKoltseg;
    private Long munkaBevetel;
    private Long munkaUzemanyagState;
    private String munkaComment;
    private String munkaBefejezesDate;
    private Boolean munkaIsActive;
    private Long munkaEstimatedTime;
    private String munkaDate;
    private Long soforID;
    private Long partnerID;
    private Long telephelyID;
    private Long munkaTipusID;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient MunkaDao myDao;

    private Sofor sofor;
    private Long sofor__resolvedKey;

    private Partner partner;
    private Long partner__resolvedKey;

    private Telephely telephely;
    private Long telephely__resolvedKey;

    private MunkaTipus munkaTipus;
    private Long munkaTipus__resolvedKey;

    private List<MunkaEszkoz> munkaEszkozList;
    private List<MunkaKep> munkaKepList;

    public Munka() {
    }

    public Munka(Long munkaID) {
        this.munkaID = munkaID;
    }

    public Munka(Long munkaID, Long munkaKoltseg, Long munkaBevetel, Long munkaUzemanyagState, String munkaComment, String munkaBefejezesDate, Boolean munkaIsActive, Long munkaEstimatedTime, String munkaDate, Long soforID, Long partnerID, Long telephelyID, Long munkaTipusID) {
        this.munkaID = munkaID;
        this.munkaKoltseg = munkaKoltseg;
        this.munkaBevetel = munkaBevetel;
        this.munkaUzemanyagState = munkaUzemanyagState;
        this.munkaComment = munkaComment;
        this.munkaBefejezesDate = munkaBefejezesDate;
        this.munkaIsActive = munkaIsActive;
        this.munkaEstimatedTime = munkaEstimatedTime;
        this.munkaDate = munkaDate;
        this.soforID = soforID;
        this.partnerID = partnerID;
        this.telephelyID = telephelyID;
        this.munkaTipusID = munkaTipusID;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getMunkaDao() : null;
    }

    public Long getMunkaID() {
        return munkaID;
    }

    public void setMunkaID(Long munkaID) {
        this.munkaID = munkaID;
    }

    public Long getMunkaKoltseg() {
        return munkaKoltseg;
    }

    public void setMunkaKoltseg(Long munkaKoltseg) {
        this.munkaKoltseg = munkaKoltseg;
    }

    public Long getMunkaBevetel() {
        return munkaBevetel;
    }

    public void setMunkaBevetel(Long munkaBevetel) {
        this.munkaBevetel = munkaBevetel;
    }

    public Long getMunkaUzemanyagState() {
        return munkaUzemanyagState;
    }

    public void setMunkaUzemanyagState(Long munkaUzemanyagState) {
        this.munkaUzemanyagState = munkaUzemanyagState;
    }

    public String getMunkaComment() {
        return munkaComment;
    }

    public void setMunkaComment(String munkaComment) {
        this.munkaComment = munkaComment;
    }

    public String getMunkaBefejezesDate() {
        return munkaBefejezesDate;
    }

    public void setMunkaBefejezesDate(String munkaBefejezesDate) {
        this.munkaBefejezesDate = munkaBefejezesDate;
    }

    public Boolean getMunkaIsActive() {
        return munkaIsActive;
    }

    public void setMunkaIsActive(Boolean munkaIsActive) {
        this.munkaIsActive = munkaIsActive;
    }

    public Long getMunkaEstimatedTime() {
        return munkaEstimatedTime;
    }

    public void setMunkaEstimatedTime(Long munkaEstimatedTime) {
        this.munkaEstimatedTime = munkaEstimatedTime;
    }

    public String getMunkaDate() {
        return munkaDate;
    }

    public void setMunkaDate(String munkaDate) {
        this.munkaDate = munkaDate;
    }

    public Long getSoforID() {
        return soforID;
    }

    public void setSoforID(Long soforID) {
        this.soforID = soforID;
    }

    public Long getPartnerID() {
        return partnerID;
    }

    public void setPartnerID(Long partnerID) {
        this.partnerID = partnerID;
    }

    public Long getTelephelyID() {
        return telephelyID;
    }

    public void setTelephelyID(Long telephelyID) {
        this.telephelyID = telephelyID;
    }

    public Long getMunkaTipusID() {
        return munkaTipusID;
    }

    public void setMunkaTipusID(Long munkaTipusID) {
        this.munkaTipusID = munkaTipusID;
    }

    /** To-one relationship, resolved on first access. */
    public Sofor getSofor() {
        if (sofor__resolvedKey == null || !sofor__resolvedKey.equals(soforID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SoforDao targetDao = daoSession.getSoforDao();
            sofor = targetDao.load(soforID);
            sofor__resolvedKey = soforID;
        }
        return sofor;
    }

    public void setSofor(Sofor sofor) {
        this.sofor = sofor;
        soforID = sofor == null ? null : sofor.getSoforID();
        sofor__resolvedKey = soforID;
    }

    /** To-one relationship, resolved on first access. */
    public Partner getPartner() {
        if (partner__resolvedKey == null || !partner__resolvedKey.equals(partnerID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            PartnerDao targetDao = daoSession.getPartnerDao();
            partner = targetDao.load(partnerID);
            partner__resolvedKey = partnerID;
        }
        return partner;
    }

    public void setPartner(Partner partner) {
        this.partner = partner;
        partnerID = partner == null ? null : partner.getPartnerID();
        partner__resolvedKey = partnerID;
    }

    /** To-one relationship, resolved on first access. */
    public Telephely getTelephely() {
        if (telephely__resolvedKey == null || !telephely__resolvedKey.equals(telephelyID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            TelephelyDao targetDao = daoSession.getTelephelyDao();
            telephely = targetDao.load(telephelyID);
            telephely__resolvedKey = telephelyID;
        }
        return telephely;
    }

    public void setTelephely(Telephely telephely) {
        this.telephely = telephely;
        telephelyID = telephely == null ? null : telephely.getTelephelyID();
        telephely__resolvedKey = telephelyID;
    }

    /** To-one relationship, resolved on first access. */
    public MunkaTipus getMunkaTipus() {
        if (munkaTipus__resolvedKey == null || !munkaTipus__resolvedKey.equals(munkaTipusID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MunkaTipusDao targetDao = daoSession.getMunkaTipusDao();
            munkaTipus = targetDao.load(munkaTipusID);
            munkaTipus__resolvedKey = munkaTipusID;
        }
        return munkaTipus;
    }

    public void setMunkaTipus(MunkaTipus munkaTipus) {
        this.munkaTipus = munkaTipus;
        munkaTipusID = munkaTipus == null ? null : munkaTipus.getMunkaTipusID();
        munkaTipus__resolvedKey = munkaTipusID;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<MunkaEszkoz> getMunkaEszkozList() {
        if (munkaEszkozList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MunkaEszkozDao targetDao = daoSession.getMunkaEszkozDao();
            munkaEszkozList = targetDao._queryMunka_MunkaEszkozList(munkaID);
        }
        return munkaEszkozList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetMunkaEszkozList() {
        munkaEszkozList = null;
    }

    /** To-many relationship, resolved on first access (and after reset). Changes to to-many relations are not persisted, make changes to the target entity. */
    public synchronized List<MunkaKep> getMunkaKepList() {
        if (munkaKepList == null) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            MunkaKepDao targetDao = daoSession.getMunkaKepDao();
            munkaKepList = targetDao._queryMunka_MunkaKepList(munkaID);
        }
        return munkaKepList;
    }

    /** Resets a to-many relationship, making the next get call to query for a fresh result. */
    public synchronized void resetMunkaKepList() {
        munkaKepList = null;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
