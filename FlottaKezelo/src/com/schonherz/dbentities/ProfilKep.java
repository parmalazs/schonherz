package com.schonherz.dbentities;

import com.schonherz.dbentities.DaoSession;
import de.greenrobot.dao.DaoException;

// THIS CODE IS GENERATED BY greenDAO, DO NOT EDIT. Enable "keep" sections if you want to edit. 
/**
 * Entity mapped to table Profilkepek.
 */
public class ProfilKep {

    private Long profilKepID;
    private String profilKepPath;
    private String profilKepDateTime;
    private Boolean profilkepIsUploaded;
    private Long soforID;

    /** Used to resolve relations */
    private transient DaoSession daoSession;

    /** Used for active entity operations. */
    private transient ProfilKepDao myDao;

    private Sofor sofor;
    private Long sofor__resolvedKey;


    public ProfilKep() {
    }

    public ProfilKep(Long profilKepID) {
        this.profilKepID = profilKepID;
    }

    public ProfilKep(Long profilKepID, String profilKepPath, String profilKepDateTime, Boolean profilkepIsUploaded, Long soforID) {
        this.profilKepID = profilKepID;
        this.profilKepPath = profilKepPath;
        this.profilKepDateTime = profilKepDateTime;
        this.profilkepIsUploaded = profilkepIsUploaded;
        this.soforID = soforID;
    }

    /** called by internal mechanisms, do not call yourself. */
    public void __setDaoSession(DaoSession daoSession) {
        this.daoSession = daoSession;
        myDao = daoSession != null ? daoSession.getProfilKepDao() : null;
    }

    public Long getProfilKepID() {
        return profilKepID;
    }

    public void setProfilKepID(Long profilKepID) {
        this.profilKepID = profilKepID;
    }

    public String getProfilKepPath() {
        return profilKepPath;
    }

    public void setProfilKepPath(String profilKepPath) {
        this.profilKepPath = profilKepPath;
    }

    public String getProfilKepDateTime() {
        return profilKepDateTime;
    }

    public void setProfilKepDateTime(String profilKepDateTime) {
        this.profilKepDateTime = profilKepDateTime;
    }

    public Boolean getProfilkepIsUploaded() {
        return profilkepIsUploaded;
    }

    public void setProfilkepIsUploaded(Boolean profilkepIsUploaded) {
        this.profilkepIsUploaded = profilkepIsUploaded;
    }

    public Long getSoforID() {
        return soforID;
    }

    public void setSoforID(Long soforID) {
        this.soforID = soforID;
    }

    /** To-one relationship, resolved on first access. */
    public Sofor getSofor() {
        if (sofor__resolvedKey == null || !sofor__resolvedKey.equals(soforID)) {
            if (daoSession == null) {
                throw new DaoException("Entity is detached from DAO context");
            }
            SoforDao targetDao = daoSession.getSoforDao();
            sofor = targetDao.load(soforID);
            sofor__resolvedKey = soforID;
        }
        return sofor;
    }

    public void setSofor(Sofor sofor) {
        this.sofor = sofor;
        soforID = sofor == null ? null : sofor.getSoforID();
        sofor__resolvedKey = soforID;
    }

    /** Convenient call for {@link AbstractDao#delete(Object)}. Entity must attached to an entity context. */
    public void delete() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.delete(this);
    }

    /** Convenient call for {@link AbstractDao#update(Object)}. Entity must attached to an entity context. */
    public void update() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.update(this);
    }

    /** Convenient call for {@link AbstractDao#refresh(Object)}. Entity must attached to an entity context. */
    public void refresh() {
        if (myDao == null) {
            throw new DaoException("Entity is detached from DAO context");
        }    
        myDao.refresh(this);
    }

}
